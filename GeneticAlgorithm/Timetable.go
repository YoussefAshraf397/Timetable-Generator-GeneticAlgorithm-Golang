package GeneticAlgorithm

import (
	"go-starter/Models"
	"math/rand"
)

type TimeTable struct {
	Teachers   map[int]Models.Teacher
	Subjects   map[int]Models.Subject
	Classrooms map[int]Models.Classroom
	TimeSlots  map[int]Models.TimeSlot
	Sessions   []Models.Session
	NumSession int
}

//func createTimeTable() {
//
//}

// AddTimeSlot s
/**
 * Add new timeslot
 *
 * @param timeslotId
 * @param timeslot
 */
func (t *TimeTable) AddTimeSlot(timeSlotID int, timeSlot string) {
	t.TimeSlots[timeSlotID] = Models.TimeSlot{
		TimeSlotID: timeSlotID,
		TimeSlot:   timeSlot,
	}
}

func (t *TimeTable) AddTeacher(teacherID int, teacherName string) {
	t.Teachers[teacherID] = Models.Teacher{
		TeacherID:   teacherID,
		TeacherName: teacherName,
	}
}

func (t *TimeTable) GetSubject(subjectID int) Models.Subject {
	return t.Subjects[subjectID]
}

func (t *TimeTable) AddSubject(subjectID int, code string, name string, teacherIDs []int) {
	t.Subjects[subjectID] = Models.Subject{
		SubjectID:  subjectID,
		Code:       code,
		Name:       name,
		TeacherIDs: teacherIDs,
	}
}

func (t *TimeTable) AddClassroom(classroomID int, capacity int, subjectIDs []int) {
	t.Classrooms[classroomID] = Models.Classroom{
		ClassroomID:       classroomID,
		ClassroomCapacity: capacity,
		SubjectIds:        subjectIDs,
	}
	t.NumSession = 0
}

func (t *TimeTable) GetNumSessions() int {
	if t.NumSession > 0 {
		return t.NumSession
	}

	numSession := 0

	classrooms := t.GetClassrooms()
	for _, classroom := range classrooms {
		numSession += len(classroom.GetSubjectIDs())
	}
	t.NumSession = numSession

	return t.NumSession
}

func (t *TimeTable) GetClassrooms() []Models.Classroom {
	keys := make([]int, 0, len(t.Classrooms))
	values := make([]Models.Classroom, 0, len(t.Classrooms))

	for k, v := range t.Classrooms {
		keys = append(keys, k)
		values = append(values, v)
	}
	return values
}

func (t *TimeTable) GetSessions() []Models.Session {
	keys := make([]int, 0, len(t.Sessions))
	values := make([]Models.Session, 0, len(t.Sessions))

	for k, v := range t.Sessions {
		keys = append(keys, k)
		values = append(values, v)
	}
	return values
}

func (t *TimeTable) GetRandomTimeSlot() Models.TimeSlot {
	timeSlotArray := t.GetTimeSlotsValues()
	timeSlot := timeSlotArray[rand.Intn(949543)%len(timeSlotArray)]
	return timeSlot
}

func (t *TimeTable) getSubject(subjectID int) Models.Subject {
	return t.Subjects[subjectID]
}

func (t *TimeTable) GetTimeSlotsValues() []Models.TimeSlot {
	v := make([]Models.TimeSlot, 0, len(t.TimeSlots))
	for _, value := range t.TimeSlots {
		v = append(v, value)
	}
	return v
}

// createClasses s
/**
 * Create classes using individual's chromosome
 *
 * One of the two important methods in this class; given a chromosome,
 * unpack it and turn it into an array of Class (with a capital C) objects.
 * These Class objects will later be evaluated by the calcClashes method,
 * which will loop through the Classes and calculate the number of
 * conflicting timeslots, rooms, professors, etc.
 *
 * While this method is important, it's not really difficult or confusing.
 * Just loop through the chromosome and create Class objects and store them.
 *
 * @param individual
 */
func (t *TimeTable) CreateSession(individual *Individual) {
	// Init classes
	t.Sessions = make([]Models.Session, t.GetNumSessions())

	// Get individual's chromosome
	chromosome := individual.Chromosome
	chromosomePos := 0
	classIndex := 0

	for _, classroom := range t.GetClassrooms() {
		subjectIDs := classroom.GetSubjectIDs()
		for _, subjectID := range subjectIDs {
			t.Sessions[classIndex] = Models.Session{
				SessionID:   classIndex,
				ClassroomID: classroom.GetClassroomID(),
				SubjectID:   subjectID,
			}

			// Add timeslot
			t.Sessions[classIndex].TimeSlotID = chromosome[chromosomePos]
			chromosomePos++

			// Add professor
			t.Sessions[classIndex].TeacherID = chromosome[chromosomePos]
			chromosomePos++

			classIndex++
		}
	}
}

/**
 * Calculate the number of clashes between Classes generated by a
 * chromosome.
 *
 * The most important method in this class; look at a candidate timetable
 * and figure out how many constraints are violated.
 *
 * Running this method requires that createClasses has been run first (in
 * order to populate this.classes). The return value of this method is
 * simply the number of constraint violations (conflicting professors,
 * timeslots, or rooms), and that return value is used by the
 * GeneticAlgorithm.calcFitness method.
 *
 * There's nothing too difficult here either -- loop through this.classes,
 * and check constraints against the rest of the this.classes.
 *
 * The two inner `for` loops can be combined here as an optimization, but
 * kept separate for clarity. For small values of this.classes.length it
 * doesn't make a difference, but for larger values it certainly does.
 *
 * @return numClashes
 */
func (t *TimeTable) CalcClashes() int {
	clashes := 0
	//con1 := ""
	//con2 := ""
	//con3 := ""
	for _, classA := range t.Sessions {
		// Check room capacity
		//roomCapacity := t.getRoom(classA.RoomID).Capacity
		//groupSize := t.getGroup(classA.GroupID).GroupSize

		//if roomCapacity < groupSize {
		//con1 = "Room capacity"
		//clashes++
		//}

		// Check if room is taken
		//for _, classB := range t.Classes {
		//	if classA.RoomID == classB.RoomID && classA.TimeSlotID == classB.TimeSlotID && classA.ClassID != classB.ClassID {
		//		//con2 = "Room is taken"
		//		clashes++
		//		break
		//	}
		//}

		//Check if professor is available
		for _, classB := range t.Sessions {
			if classA.TeacherID == classB.TeacherID && classA.TimeSlotID == classB.TimeSlotID && classA.SessionID != classB.SessionID {
				//con3 = "Professor is busy"
				clashes++
				break
			}
		}
	}
	//fmt.Println(con1, con2, con3)

	return clashes
}

/**
 * Get group from groupId
 *
 * @param groupId
 * @return group
 */
func (t *TimeTable) GetClassroom(classroomID int) Models.Classroom {
	return t.Classrooms[classroomID]
}
